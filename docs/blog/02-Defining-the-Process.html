<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Defining the Process</title>
    <link rel="stylesheet" href="">
</head>
<body>
<main>

<h1 id='defining_the_process'>Defining the Process</h1>

<h3 id='quick_summary'>Quick Summary</h3>

<blockquote>
<p>At this stage we know what we <em>might</em> build. It&#8217;s time to start defining that
thing in a language that is amenable to the hardware we have available.
<br />This is much like the measurement phase of painting. Certain rules must be met
for the painting to be compatible with our intuition about how 3D shapes work.
<br /></p>

<h2 id='how_can_we_specify_state_machines?'>How can we specify state machines?</h2>
</blockquote>

<p>A state machine can be specified as a relation between predicates over input
streams and predicates over output streams.</p>

<h3 id='ui_specification'>UI Specification</h3>

<p>In this case the input stream carries <em>UI Actions</em> and the output stream carries
<em>UI States</em>. When a user inputs a sequence of UI actions that satisfies some
predicate, the UI will produce a sequence of states that satisfy some other
predicate.</p>

<p>For example, in the Finance Application we expect the Transaction List to update
whenver the user submits a new transaction form. This can expressed as</p>

<pre><code class="language-feature">Scenario: submitting an income entry form
    Given   the page has loaded
    When    the user submits an Income Entry
    Then    the Transactions List contains the Income Entry</code></pre>

<h3 id='notes'>Notes</h3>

<ul>
<li>Underlying semantics is the log of input events</li>

<li>Do changes propogate immediately or on sync?</li>

<li>~~Each component has a cached copy of the state~~</li>

<li>Each component owns a log of events from other components or environment</li>

<li>This might be too many logs for applications; current state is a &quot;compressed&quot;
version of log entries</li>

<li>
<p>Each component is specified by a state machine that ingests events,
updates its state, and emits other events</p>

<h3 id='temoporal_specification'>Temoporal Specification</h3>
</li>
</ul>

<p>LTL lets us specify predicates over a linear (non-branching) sequence of evets.</p>

<p>For this app, the LTL formulas I need include</p>

<p>&quot;For all P eventually Q&quot;, after some event that matches P, there is eventually an event that matches Q</p>

<p>&quot;For all P never Q&quot;, after some event matches P, there are no subsequent events matching Q</p>

<p>The complexity of model-checking formulas like this is O(n^2) for n the length of the model instance, i.e. number of events in the sequence.</p>


</main>
</body>
</html>
